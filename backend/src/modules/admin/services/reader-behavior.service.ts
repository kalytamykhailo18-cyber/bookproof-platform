import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '@common/prisma/prisma.service';
import { AuditService } from '../../audit/audit.service';
import {
  CreateBehaviorFlagDto,
  InvestigateBehaviorFlagDto,
  TakeActionDto,
  GetBehaviorFlagsQueryDto,
  BehaviorFlagResponseDto,
  ReaderBehaviorReportDto,
  SuspiciousReaderDto,
  BehaviorFlagStatus,
  BehaviorFlagType,
} from '../dto/reader-behavior.dto';
import { IssueSeverity } from '../../reviews/dto/validate-review.dto';
import { UserRole } from '@prisma/client';

@Injectable()
export class ReaderBehaviorService {
  private readonly logger = new Logger(ReaderBehaviorService.name);

  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
  ) {}

  /**
   * Automated Multiple-IP Detection Job
   * Runs daily to detect readers who share IP addresses (potential fraud networks)
   */
  @Cron(CronExpression.EVERY_DAY_AT_3AM)
  async detectMultipleIpReaders(): Promise<void> {
    this.logger.log('Starting automated multiple-IP detection for readers...');

    try {
      // Find IP addresses that have been used by multiple reader accounts
      // We look at affiliate referrals and login patterns (if tracked)
      const suspiciousIps = await this.prisma.$queryRaw<Array<{ ipAddress: string; readerCount: number }>>`
        SELECT ip_address as "ipAddress", COUNT(DISTINCT reader_profile_id) as "readerCount"
        FROM (
          -- Get IPs from affiliate referrals (readers who registered)
          SELECT DISTINCT ar.ip_address, rp.id as reader_profile_id
          FROM affiliate_referral ar
          JOIN author_profile ap ON ar.referred_author_id = ap.id
          JOIN "User" u ON ap.user_id = u.id
          JOIN reader_profile rp ON rp.user_id = u.id
          WHERE ar.ip_address IS NOT NULL
            AND ar.registered_at >= NOW() - INTERVAL '30 days'

          UNION ALL

          -- Get IPs from affiliate clicks that converted
          SELECT DISTINCT ac.ip_address, rp.id as reader_profile_id
          FROM affiliate_click ac
          JOIN affiliate_referral ar ON ac.cookie_id = ar.cookie_id
          JOIN author_profile ap ON ar.referred_author_id = ap.id
          JOIN "User" u ON ap.user_id = u.id
          JOIN reader_profile rp ON rp.user_id = u.id
          WHERE ac.ip_address IS NOT NULL
            AND ac.clicked_at >= NOW() - INTERVAL '30 days'
        ) ip_readers
        WHERE ip_address != 'unknown'
        GROUP BY ip_address
        HAVING COUNT(DISTINCT reader_profile_id) >= 3
        ORDER BY "readerCount" DESC
        LIMIT 100
      `;

      this.logger.log(`Found ${suspiciousIps.length} IPs with multiple reader accounts`);

      for (const ipData of suspiciousIps) {
        // Get the reader profiles associated with this IP
        const readersWithIp = await this.getReadersFromIp(ipData.ipAddress);

        for (const readerProfileId of readersWithIp) {
          // Check if already flagged for MULTIPLE_IP
          const existingFlag = await this.prisma.readerBehaviorFlag.findFirst({
            where: {
              readerProfileId,
              flagType: 'MULTIPLE_IP' as any,
              status: { in: ['ACTIVE', 'CONFIRMED'] },
            },
          });

          if (!existingFlag) {
            // Create auto-generated flag
            await this.prisma.readerBehaviorFlag.create({
              data: {
                readerProfileId,
                flagType: 'MULTIPLE_IP' as any,
                severity: ipData.readerCount >= 5 ? 'HIGH' : 'MEDIUM',
                description: `Detected ${ipData.readerCount} reader accounts from IP address ${this.maskIpAddress(ipData.ipAddress)}`,
                evidenceData: JSON.stringify({
                  ipAddress: this.maskIpAddress(ipData.ipAddress),
                  totalReadersFromIp: ipData.readerCount,
                  detectedAt: new Date().toISOString(),
                }),
                scoreImpact: ipData.readerCount >= 5 ? -15 : -10,
                status: 'ACTIVE' as any,
                isAutoGenerated: true,
              },
            });

            this.logger.warn(
              `Auto-flagged reader ${readerProfileId} for MULTIPLE_IP (${ipData.readerCount} accounts from same IP)`,
            );
          }
        }
      }

      this.logger.log('Completed automated multiple-IP detection');
    } catch (error) {
      this.logger.error('Error in multiple-IP detection job:', error);
    }
  }

  /**
   * Get reader profile IDs associated with an IP address
   */
  private async getReadersFromIp(ipAddress: string): Promise<string[]> {
    const readers = await this.prisma.$queryRaw<Array<{ readerProfileId: string }>>`
      SELECT DISTINCT rp.id as "readerProfileId"
      FROM reader_profile rp
      JOIN "User" u ON rp.user_id = u.id
      LEFT JOIN author_profile ap ON ap.user_id = u.id
      LEFT JOIN affiliate_referral ar ON ar.referred_author_id = ap.id
      LEFT JOIN affiliate_click ac ON ac.cookie_id = ar.cookie_id
      WHERE (ar.ip_address = ${ipAddress} OR ac.ip_address = ${ipAddress})
    `;

    return readers.map((r) => r.readerProfileId);
  }

  /**
   * Mask IP address for privacy (show only first 2 octets)
   */
  private maskIpAddress(ip: string): string {
    const parts = ip.split('.');
    if (parts.length === 4) {
      return `${parts[0]}.${parts[1]}.***.***`;
    }
    return '***.***.***';
  }

  /**
   * Manually trigger multiple-IP detection (for admin use)
   */
  async runMultipleIpDetection(): Promise<{ detected: number; flagsCreated: number }> {
    let flagsCreated = 0;

    // Simplified detection using registration data correlation
    const duplicateIpReaders = await this.prisma.$queryRaw<
      Array<{ readerProfileId: string; ipAddress: string; count: number }>
    >`
      SELECT
        rp.id as "readerProfileId",
        ar.ip_address as "ipAddress",
        COUNT(*) OVER (PARTITION BY ar.ip_address) as count
      FROM reader_profile rp
      JOIN "User" u ON rp.user_id = u.id
      JOIN author_profile ap ON ap.user_id = u.id
      JOIN affiliate_referral ar ON ar.referred_author_id = ap.id
      WHERE ar.ip_address IS NOT NULL
        AND ar.ip_address != 'unknown'
      HAVING COUNT(*) OVER (PARTITION BY ar.ip_address) >= 2
    `;

    const processedReaders = new Set<string>();

    for (const data of duplicateIpReaders) {
      if (processedReaders.has(data.readerProfileId)) continue;
      processedReaders.add(data.readerProfileId);

      // Check if already flagged
      const existingFlag = await this.prisma.readerBehaviorFlag.findFirst({
        where: {
          readerProfileId: data.readerProfileId,
          flagType: 'MULTIPLE_IP' as any,
          status: { in: ['ACTIVE', 'CONFIRMED'] },
        },
      });

      if (!existingFlag && data.count >= 2) {
        await this.prisma.readerBehaviorFlag.create({
          data: {
            readerProfileId: data.readerProfileId,
            flagType: 'MULTIPLE_IP' as any,
            severity: data.count >= 5 ? 'HIGH' : 'MEDIUM',
            description: `Detected ${data.count} reader accounts from same IP address`,
            evidenceData: JSON.stringify({
              ipAddress: this.maskIpAddress(data.ipAddress),
              totalReadersFromIp: data.count,
              detectedAt: new Date().toISOString(),
            }),
            scoreImpact: data.count >= 5 ? -15 : -10,
            status: 'ACTIVE' as any,
            isAutoGenerated: true,
          },
        });
        flagsCreated++;
      }
    }

    return {
      detected: processedReaders.size,
      flagsCreated,
    };
  }

  /**
   * Analyze reader behavior and return behavior report
   */
  async analyzeReaderBehavior(readerProfileId: string): Promise<ReaderBehaviorReportDto> {
    const readerProfile = await this.prisma.readerProfile.findUnique({
      where: { id: readerProfileId },
      include: {
        user: true,
        assignments: {
          include: {
            review: true,
          },
        },
      },
    });

    if (!readerProfile) {
      throw new NotFoundException('Reader profile not found');
    }

    // Get active flags for this reader
    const activeFlags = await this.prisma.readerBehaviorFlag.findMany({
      where: {
        readerProfileId,
        status: 'ACTIVE' as any,
      },
      orderBy: { createdAt: 'desc' },
    });

    // Calculate metrics
    const completedAssignments = readerProfile.assignments.filter(
      (a) => a.status === 'COMPLETED' || a.status === 'VALIDATED',
    );
    const expiredAssignments = readerProfile.assignments.filter(
      (a) => a.status === 'EXPIRED',
    );

    // Calculate average review time (from material release to submission)
    let totalReviewTime = 0;
    let reviewsWithTime = 0;
    for (const assignment of completedAssignments) {
      if (assignment.materialsReleasedAt && assignment.review?.submittedAt) {
        const timeInMs =
          new Date(assignment.review.submittedAt).getTime() -
          new Date(assignment.materialsReleasedAt).getTime();
        totalReviewTime += timeInMs / (1000 * 60 * 60); // Convert to hours
        reviewsWithTime++;
      }
    }
    const averageReviewTime = reviewsWithTime > 0 ? totalReviewTime / reviewsWithTime : 0;

    // Calculate account age
    const accountAge = Math.floor(
      (Date.now() - new Date(readerProfile.createdAt).getTime()) / (1000 * 60 * 60 * 24),
    );

    // Determine risk level based on flags and metrics
    let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'LOW';
    if (activeFlags.length >= 3 || activeFlags.some((f) => f.severity === 'CRITICAL')) {
      riskLevel = 'CRITICAL';
    } else if (activeFlags.length >= 2 || activeFlags.some((f) => f.severity === 'HIGH')) {
      riskLevel = 'HIGH';
    } else if (activeFlags.length >= 1) {
      riskLevel = 'MEDIUM';
    }

    return {
      readerProfileId,
      readerName: readerProfile.user.name,
      readerEmail: readerProfile.user.email,
      reliabilityScore: readerProfile.reliabilityScore
        ? parseFloat(readerProfile.reliabilityScore.toString())
        : 100,
      completionRate: readerProfile.completionRate
        ? parseFloat(readerProfile.completionRate.toString())
        : 100,
      totalReviews: readerProfile.reviewsCompleted,
      rejectedReviews: readerProfile.reviewsRejected,
      expiredAssignments: expiredAssignments.length,
      reviewsRemovedByAmazon: readerProfile.reviewsRemovedByAmazon,
      averageReviewTime: Math.round(averageReviewTime * 10) / 10,
      accountAge,
      activeFlags: activeFlags.map((f) => this.mapToFlagResponseDto(f)),
      flagCount: activeFlags.length,
      isFlagged: readerProfile.isFlagged,
      flagReason: readerProfile.flagReason || undefined,
      isActive: readerProfile.isActive,
      riskLevel,
    };
  }

  /**
   * Flag a suspicious reader manually
   */
  async flagSuspiciousReader(
    dto: CreateBehaviorFlagDto,
    adminUserId: string,
  ): Promise<BehaviorFlagResponseDto> {
    // Verify reader exists
    const readerProfile = await this.prisma.readerProfile.findUnique({
      where: { id: dto.readerProfileId },
    });

    if (!readerProfile) {
      throw new NotFoundException('Reader profile not found');
    }

    const flag = await this.prisma.readerBehaviorFlag.create({
      data: {
        readerProfileId: dto.readerProfileId,
        flagType: dto.flagType as any,
        severity: (dto.severity || IssueSeverity.MEDIUM) as any,
        description: dto.description,
        evidenceData: dto.evidenceData,
        scoreImpact: dto.scoreImpact || 0,
        status: 'ACTIVE' as any,
        isAutoGenerated: false,
      },
    });

    // Update reader profile if needed
    if (!readerProfile.isFlagged) {
      await this.prisma.readerProfile.update({
        where: { id: dto.readerProfileId },
        data: {
          isFlagged: true,
          flagReason: dto.description,
          flaggedAt: new Date(),
          flaggedBy: adminUserId,
        },
      });
    }

    // Log audit trail
    await this.auditService.logAdminAction({
      action: 'reader_behavior.flagged',
      entity: 'ReaderBehaviorFlag',
      entityId: flag.id,
      userId: adminUserId,
      userEmail: '', // Admin email not available in context
      userRole: UserRole.ADMIN,
      description: `Reader flagged for suspicious behavior: ${dto.flagType}`,
      changes: {
        readerProfileId: dto.readerProfileId,
        flagType: dto.flagType,
        severity: dto.severity,
      },
    });

    return this.mapToFlagResponseDto(flag);
  }

  /**
   * Get reader behavior report
   */
  async getReaderBehaviorReport(readerProfileId: string): Promise<ReaderBehaviorReportDto> {
    return this.analyzeReaderBehavior(readerProfileId);
  }

  /**
   * Get list of suspicious readers
   */
  async getSuspiciousReaders(): Promise<SuspiciousReaderDto[]> {
    // Get readers with active flags
    const flaggedReaders = await this.prisma.readerBehaviorFlag.groupBy({
      by: ['readerProfileId'],
      where: {
        status: 'ACTIVE' as any,
      },
      _count: {
        id: true,
      },
      _max: {
        severity: true,
        createdAt: true,
      },
    });

    if (flaggedReaders.length === 0) return [];

    // Batch fetch all reader profiles in one query
    const readerProfileIds = flaggedReaders.map((fg) => fg.readerProfileId);
    const readerProfiles = await this.prisma.readerProfile.findMany({
      where: { id: { in: readerProfileIds } },
      include: {
        user: true,
      },
    });

    // Batch fetch all flags in one query
    const allFlags = await this.prisma.readerBehaviorFlag.findMany({
      where: {
        readerProfileId: { in: readerProfileIds },
        status: 'ACTIVE' as any,
      },
      select: {
        readerProfileId: true,
        flagType: true,
      },
    });

    // Build lookup maps for O(1) access
    const readerProfileMap = new Map(
      readerProfiles.map((rp) => [rp.id, rp]),
    );
    const flagsMap = new Map<string, BehaviorFlagType[]>();
    allFlags.forEach((flag) => {
      if (!flagsMap.has(flag.readerProfileId)) {
        flagsMap.set(flag.readerProfileId, []);
      }
      flagsMap.get(flag.readerProfileId)!.push(flag.flagType as BehaviorFlagType);
    });

    // Build results from batched data
    const results: SuspiciousReaderDto[] = [];
    for (const flagGroup of flaggedReaders) {
      const readerProfile = readerProfileMap.get(flagGroup.readerProfileId);
      if (!readerProfile) continue;

      const flags = flagsMap.get(flagGroup.readerProfileId) || [];

      results.push({
        readerProfileId: readerProfile.id,
        readerName: readerProfile.user.name,
        readerEmail: readerProfile.user.email,
        reliabilityScore: readerProfile.reliabilityScore
          ? parseFloat(readerProfile.reliabilityScore.toString())
          : 100,
        activeFlagCount: flagGroup._count.id,
        highestSeverity: (flagGroup._max.severity as IssueSeverity) || IssueSeverity.LOW,
        flagTypes: flags,
        lastFlagDate: flagGroup._max.createdAt || new Date(),
        isFlagged: readerProfile.isFlagged,
        isActive: readerProfile.isActive,
      });
    }

    // Sort by flag count and severity
    return results.sort((a, b) => {
      const severityOrder = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
      const aSeverity = severityOrder[a.highestSeverity] || 0;
      const bSeverity = severityOrder[b.highestSeverity] || 0;
      if (aSeverity !== bSeverity) return bSeverity - aSeverity;
      return b.activeFlagCount - a.activeFlagCount;
    });
  }

  /**
   * Get behavior flags with filters
   */
  async getBehaviorFlags(query: GetBehaviorFlagsQueryDto): Promise<BehaviorFlagResponseDto[]> {
    const where: any = {};

    if (query.status) {
      where.status = query.status;
    }
    if (query.flagType) {
      where.flagType = query.flagType;
    }
    if (query.severity) {
      where.severity = query.severity;
    }
    if (query.readerProfileId) {
      where.readerProfileId = query.readerProfileId;
    }
    if (query.isAutoGenerated !== undefined) {
      where.isAutoGenerated = query.isAutoGenerated;
    }

    const flags = await this.prisma.readerBehaviorFlag.findMany({
      where,
      orderBy: [
        { severity: 'desc' },
        { createdAt: 'desc' },
      ],
    });

    return flags.map((f) => this.mapToFlagResponseDto(f));
  }

  /**
   * Investigate a behavior flag
   */
  async investigateBehaviorFlag(
    flagId: string,
    dto: InvestigateBehaviorFlagDto,
    adminUserId: string,
  ): Promise<BehaviorFlagResponseDto> {
    const flag = await this.prisma.readerBehaviorFlag.findUnique({
      where: { id: flagId },
    });

    if (!flag) {
      throw new NotFoundException('Behavior flag not found');
    }

    const updatedFlag = await this.prisma.readerBehaviorFlag.update({
      where: { id: flagId },
      data: {
        status: dto.status as any,
        investigatedBy: adminUserId,
        investigatedAt: new Date(),
        investigationNotes: dto.investigationNotes,
      },
    });

    // Log audit trail
    await this.auditService.logAdminAction({
      action: 'reader_behavior.investigated',
      entity: 'ReaderBehaviorFlag',
      entityId: flagId,
      userId: adminUserId,
      userEmail: '', // Admin email not available in context
      userRole: UserRole.ADMIN,
      description: `Behavior flag investigated: ${dto.status}`,
      changes: {
        previousStatus: flag.status,
        newStatus: dto.status,
        investigationNotes: dto.investigationNotes,
      },
    });

    return this.mapToFlagResponseDto(updatedFlag);
  }

  /**
   * Take action on a behavior flag
   */
  async takeAction(
    flagId: string,
    dto: TakeActionDto,
    adminUserId: string,
  ): Promise<BehaviorFlagResponseDto> {
    const flag = await this.prisma.readerBehaviorFlag.findUnique({
      where: { id: flagId },
    });

    if (!flag) {
      throw new NotFoundException('Behavior flag not found');
    }

    // Update the flag
    const updatedFlag = await this.prisma.readerBehaviorFlag.update({
      where: { id: flagId },
      data: {
        actionTaken: dto.action,
        actionTakenAt: new Date(),
        actionTakenBy: adminUserId,
        status: dto.action === 'DISMISSED' ? 'DISMISSED' : 'CONFIRMED' as any,
      },
    });

    // Update reader profile based on action
    if (dto.action === 'SUSPENDED' || dto.action === 'BANNED') {
      await this.prisma.readerProfile.update({
        where: { id: flag.readerProfileId },
        data: {
          isActive: dto.action === 'BANNED' ? false : true,
          isFlagged: true,
          flagReason: dto.notes || `Account ${dto.action.toLowerCase()}`,
          flaggedBy: adminUserId,
          flaggedAt: new Date(),
        },
      });
    } else if (dto.action === 'DISMISSED') {
      // Check if there are other active flags
      const otherFlags = await this.prisma.readerBehaviorFlag.count({
        where: {
          readerProfileId: flag.readerProfileId,
          status: 'ACTIVE' as any,
          id: { not: flagId },
        },
      });

      if (otherFlags === 0) {
        await this.prisma.readerProfile.update({
          where: { id: flag.readerProfileId },
          data: {
            isFlagged: false,
            flagReason: null,
          },
        });
      }
    }

    // Log audit trail
    await this.auditService.logAdminAction({
      action: 'reader_behavior.action_taken',
      entity: 'ReaderBehaviorFlag',
      entityId: flagId,
      userId: adminUserId,
      userEmail: '', // Admin email not available in context
      userRole: UserRole.ADMIN,
      description: `Action taken on behavior flag: ${dto.action}`,
      changes: {
        readerProfileId: flag.readerProfileId,
        action: dto.action,
        notes: dto.notes,
      },
    });

    return this.mapToFlagResponseDto(updatedFlag);
  }

  /**
   * Get behavior statistics for dashboard
   */
  async getBehaviorStats(): Promise<{
    totalFlags: number;
    activeFlags: number;
    suspiciousReaders: number;
    byFlagType: Record<string, number>;
    bySeverity: Record<string, number>;
    byAction: Record<string, number>;
  }> {
    const [
      totalFlags,
      activeFlags,
      suspiciousReadersCount,
      byFlagType,
      bySeverity,
      byAction,
    ] = await Promise.all([
      this.prisma.readerBehaviorFlag.count(),
      this.prisma.readerBehaviorFlag.count({ where: { status: 'ACTIVE' } }),
      this.prisma.readerProfile.count({ where: { isFlagged: true } }),
      this.prisma.readerBehaviorFlag.groupBy({
        by: ['flagType'],
        _count: { flagType: true },
      }),
      this.prisma.readerBehaviorFlag.groupBy({
        by: ['severity'],
        _count: { severity: true },
      }),
      this.prisma.readerBehaviorFlag.groupBy({
        by: ['actionTaken'],
        where: { actionTaken: { not: null } },
        _count: { actionTaken: true },
      }),
    ]);

    return {
      totalFlags,
      activeFlags,
      suspiciousReaders: suspiciousReadersCount,
      byFlagType: byFlagType.reduce((acc, item) => {
        acc[item.flagType] = item._count.flagType;
        return acc;
      }, {} as Record<string, number>),
      bySeverity: bySeverity.reduce((acc, item) => {
        acc[item.severity] = item._count.severity;
        return acc;
      }, {} as Record<string, number>),
      byAction: byAction.reduce((acc, item) => {
        if (item.actionTaken) {
          acc[item.actionTaken] = item._count.actionTaken;
        }
        return acc;
      }, {} as Record<string, number>),
    };
  }

  /**
   * Map Prisma flag to response DTO
   */
  private mapToFlagResponseDto(flag: any): BehaviorFlagResponseDto {
    return {
      id: flag.id,
      readerProfileId: flag.readerProfileId,
      flagType: flag.flagType,
      severity: flag.severity,
      description: flag.description,
      evidenceData: flag.evidenceData,
      scoreImpact: flag.scoreImpact,
      status: flag.status,
      investigatedBy: flag.investigatedBy,
      investigatedAt: flag.investigatedAt,
      investigationNotes: flag.investigationNotes,
      actionTaken: flag.actionTaken,
      actionTakenAt: flag.actionTakenAt,
      actionTakenBy: flag.actionTakenBy,
      isAutoGenerated: flag.isAutoGenerated,
      createdAt: flag.createdAt,
      updatedAt: flag.updatedAt,
    };
  }
}
